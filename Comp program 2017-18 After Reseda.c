#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    mobile1,        sensorPotentiometer)
#pragma config(Sensor, in2,    mobile2,        sensorPotentiometer)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           mobileRight,   tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           FRLift,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           leftDrive,     tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           BRLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           slider,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           BLLift,        tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port8,           rightDrive,    tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,           FLLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          mobileLeft,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard                !!*//

#include "voids.c"

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

void pre_auton()
{

}
#define MOBILEGOALTIME 500
#define MOBILEGOALEXTRATIME 100
#define SQUARE2 2250
#define EXTRATIME 400
#define TURN45 400
#define SCISSORTIME 1000
#define SLIDERTIME 5000
//TURN45 is only kind of accurate
#define SPEEDFORWARD 127 //this closes the claw if you use it for the claw
#define SPEEDBACK -127 //this opens the claw if you use it for the claw
#define CLAWOPENTIME 2000

task autonomous()
{
						//first auton
						liftMobileGoal(MOBILEGOALTIME, -127);
						go_forth(SQUARE2+EXTRATIME+EXTRATIME);
						openClaw(SPEEDFORWARD);
						scissorLift(SCISSORTIME);
						moveSlider(SLIDERTIME, 127);
						openClaw(SPEEDBACK);
						stopClaw(CLAWOPENTIME); //this part works 5/5 as long as you set the robot up right.
						liftMobileGoal(MOBILEGOALTIME, 127);
						go_back(SQUARE2+EXTRATIME+EXTRATIME);
						turn(TURN45*4);
						liftMobileGoal(MOBILEGOALTIME, -127);
						go_forth(EXTRATIME*2);
						go_back(EXTRATIME*2); //this part works 5/5 as long as you set the robot up right.


						////second auton
						//liftMobileGoal(MOBILEGOALTIME, -127);
						//go_forth(SQUARE2+EXTRATIME+EXTRATIME);
						//openClaw(SPEEDFORWARD);
						//scissorLift(SCISSORTIME);
						//moveSlider(SLIDERTIME);
						//openClaw(SPEEDBACK);
						//stopClaw(CLAWOPENTIME);

	//moveSlider(SLIDERTIME);
	//motor[leftDrive] = 127;
	//motor[rightDrive] = 127;
	//motor[mobileLeft] =-127;
	//motor[mobileRight] =-127;
	//wait1Msec(SQUARE3);
	//motor[mobileLeft] =0;
	//motor[mobileRight] =0;
	//motor[leftDrive]=0;
	//motor[rightDrive]=0;
	//wait1Msec(500);
	//liftMobileGoal(MOBILEGOALTIME, 127);
	//go_back(SQUARE3+EXTRATIME);
	//liftMobileGoal(MOBILEGOALDOWNTIME, -127);
	//go_back(1000);
	//liftMobileGoal(MOBILEGOALTIME);
	//go_forth(SQUARE3+EXTRATIME);
	////turn(500);
	//liftMobileGoal(-MOBILEGOALDOWNTIME);
	////The negitive version of down is up
	//go_back(SQUARE3-300);
	///*We need to not go quite as far for this back because
	//of all the other stuff after this*/
	//turn(-TURN45*2);
	////We need to turn 90 degrees not 45
	//go_forth(EXTRATIME);
	//turn(-TURN45*3);
	////We need to turn 135 degrees and 45*3 is 135.
	//go_forth(400);
	//go_back(100);
	//go_forth(100);
	//go_back(100);
	//go_forth(100);
	//go_back(200);
}

task usercontrol()
{
	while (true)
	{

		motor[leftDrive] = vexRT[Ch2];
		motor[rightDrive] = vexRT[Ch3];
		motor[FLLift] = -vexRT[Ch3Xmtr2];
		motor[FRLift] = vexRT[Ch2Xmtr2];
		motor[BLLift] = vexRT[Ch3Xmtr2];
		motor[BRLift] = -vexRT[Ch2Xmtr2];
		//Button 6 Up Opens claw
		//Button 6 Down Closes claw
		if(vexRT[Btn6UXmtr2]==1)
		{
			motor[claw] = 127;
		}
		else if(vexRT[Btn6DXmtr2] == 1)
		{
			motor[claw] = -127;
		}
		else
		{
			motor[claw] = 0;
		}
		/*Button 5 Up (partner) moves the slider (hopefully
		forward)
		Button 5 Down (partner) moves the slider
		backwards (if the other button moves it forwards)*/
		if(vexRT[Btn5UXmtr2]==1)
		{
			motor[slider] = 100;
		}
		else if(vexRT[Btn5DXmtr2]==1)
		{
			motor[slider] = -100;
		}
		else
		{
			motor[slider] = 0;
		}
		/*Button 5 Up moves the mobile goal lift up
		Button 5 Down moves the mobile goal lift down*/
		if(vexRT[Btn5U]==1)
		{
			motor[mobileLeft] = 127;
			motor[mobileRight] = 127;
		}
		else if(vexRT[Btn5D]==1)
		{
			motor[mobileLeft]= -127;
			motor[mobileRight]= -127;
		}
		else
		{
			motor[mobileLeft]=0;
			motor[mobileRight]=0;
		}
	}
}
